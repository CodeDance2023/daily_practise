//
////内存超出限制
//#include <iostream>
//using namespace std;
//int n, m, dp[3408][12888], w[3408], v[3408];
////dp数组代表在[0~i]的物品中，任取放进容量为j的背包中的最大价值
////w数组为背包的容量
////v数组为物品的价值
//int main()
//{
//	cin >> n >> m;
//	for (int i = 0; i < n; ++i) cin >> w[i] >> v[i];   //输入第i个物品的重量和价值
//	//初始化
//	for (int j = 1; j <= m; ++j)
//	{
//		if (j >= w[0]) dp[0][j] = v[0];  //初始化第一行背包的最大价值，物品从0开始到n
//	}
//	//遍历递推
//	for (int i = 1; i < n; ++i)   //第i个物品
//	{
//		for (int j = 1; j <= m; ++j)     //背包的容量
//		{
//			if (j >= w[i])  //看这个物品的重量是否小于或者等于背包的容量，否则放不下
//			{
//				dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - w[i]] + v[i]); //放和不放第i个物品
//			}
//			else
//			{
//				dp[i][j] = dp[i - 1][j]; //当前物品放不进背包中
//			}
//		}
//	}
//	cout << dp[n - 1][m];    //输入从0~n-1个商品中任选放进容量为m的背包时最大的价值，即右下角最后一个空格
//}
//
////滚动数组版本的01背包问题
//#include <iostream>
//using namespace std;
////dp数组含义为：容量为j的背包中的最大价值
//int n, m, dp[12888], w[3408], v[3408];
//int main()
//{
//	cin >> n >> m;
//	for (int i = 0; i < n; ++i) cin >> w[i] >> v[i]; //输入物品i的重量和价值
//	for (int i = 0; i < n; ++i)   //遍历物品
//	{
//		for (int j = m; j >= 0; --j) //利用一位数组遍历时背包容量需要倒序，防止一维数组的上一个状态会被当前的状态的值所覆盖，即用完再覆盖
//		{
//			if (w[i] <= j) //看物品的重量是否小于或者等于背包的容量
//			{
//				//如果满足条件，则有放和不放i物品两种选择
//				dp[j] = max(dp[j], dp[j - w[i]] + v[i]);
//			}
//		}
//	}
//	cout << dp[m];    //输出容量为m的背包的最大价值
//}


